<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MCUX CLNS: mcuxClMath_Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MCUX CLNS
   </div>
   <div id="projectbrief">MCUX Crypto Library Normal Secure</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__mcux_cl_math___functions.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">mcuxClMath_Functions<div class="ingroups"><a class="el" href="group__mcux_cl_math.html">mcuxClMath</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Defines all functions of <a class="el" href="group__mcux_cl_math.html">mcuxClMath</a>.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaadd4485b0f1db32b6da6e6b7a2e6cc11"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gaadd4485b0f1db32b6da6e6b7a2e6cc11">MCUXCLMATH_SHIFTMODULUS</a>(iNShifted,  iN)</td></tr>
<tr class="memdesc:gaadd4485b0f1db32b6da6e6b7a2e6cc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for #mcuxClMath_ShiftModulus.  <a href="#gaadd4485b0f1db32b6da6e6b7a2e6cc11">More...</a><br /></td></tr>
<tr class="separator:gaadd4485b0f1db32b6da6e6b7a2e6cc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35df7cdad4c81c5e276f373c70c571d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga35df7cdad4c81c5e276f373c70c571d0">MCUXCLMATH_FP_SHIFTMODULUS</a>(iNShifted,  iN)</td></tr>
<tr class="memdesc:ga35df7cdad4c81c5e276f373c70c571d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for #mcuxClMath_ShiftModulus with flow protection.  <a href="#ga35df7cdad4c81c5e276f373c70c571d0">More...</a><br /></td></tr>
<tr class="separator:ga35df7cdad4c81c5e276f373c70c571d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab588855e23f750a4c9f7533b54a11325"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gab588855e23f750a4c9f7533b54a11325">MCUXCLMATH_NDASH</a>(iN,  iT)</td></tr>
<tr class="memdesc:gab588855e23f750a4c9f7533b54a11325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for #mcuxClMath_NDash.  <a href="#gab588855e23f750a4c9f7533b54a11325">More...</a><br /></td></tr>
<tr class="separator:gab588855e23f750a4c9f7533b54a11325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa0d390f4eb5728edfd764936aeee313"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gafa0d390f4eb5728edfd764936aeee313">MCUXCLMATH_FP_NDASH</a>(iN,  iT)</td></tr>
<tr class="memdesc:gafa0d390f4eb5728edfd764936aeee313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for #mcuxClMath_NDash with flow protection.  <a href="#gafa0d390f4eb5728edfd764936aeee313">More...</a><br /></td></tr>
<tr class="separator:gafa0d390f4eb5728edfd764936aeee313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga666d3347d6f96a09b791355e596de46d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga666d3347d6f96a09b791355e596de46d">MCUXCLMATH_QDASH</a>(iQDash,  iNShifted,  iN,  iT,  len)</td></tr>
<tr class="memdesc:ga666d3347d6f96a09b791355e596de46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for #mcuxClMath_QDash.  <a href="#ga666d3347d6f96a09b791355e596de46d">More...</a><br /></td></tr>
<tr class="separator:ga666d3347d6f96a09b791355e596de46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7703703d552c5446acdf38d82cd81971"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga7703703d552c5446acdf38d82cd81971">MCUXCLMATH_FP_QDASH</a>(iQDash,  iNShifted,  iN,  iT,  len)</td></tr>
<tr class="memdesc:ga7703703d552c5446acdf38d82cd81971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for #mcuxClMath_QDash with flow protection.  <a href="#ga7703703d552c5446acdf38d82cd81971">More...</a><br /></td></tr>
<tr class="separator:ga7703703d552c5446acdf38d82cd81971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ee6d9b078ecc35a081a3a8cdbec0968"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga4ee6d9b078ecc35a081a3a8cdbec0968">MCUXCLMATH_QSQUARED</a>(iQSqr,  iNShifted,  iN,  iT)</td></tr>
<tr class="memdesc:ga4ee6d9b078ecc35a081a3a8cdbec0968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for #mcuxClMath_QSquared.  <a href="#ga4ee6d9b078ecc35a081a3a8cdbec0968">More...</a><br /></td></tr>
<tr class="separator:ga4ee6d9b078ecc35a081a3a8cdbec0968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcd348426e9998703dc6f93194a62f80"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gadcd348426e9998703dc6f93194a62f80">MCUXCLMATH_FP_QSQUARED</a>(iQSqr,  iNShifted,  iN,  iT)</td></tr>
<tr class="memdesc:gadcd348426e9998703dc6f93194a62f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for #mcuxClMath_QSquared with flow protection.  <a href="#gadcd348426e9998703dc6f93194a62f80">More...</a><br /></td></tr>
<tr class="separator:gadcd348426e9998703dc6f93194a62f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa59866fd485a59868a2a594a5858f1de"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gaa59866fd485a59868a2a594a5858f1de">MCUXCLMATH_MODINV</a>(iR,  iX,  iN,  iT)</td></tr>
<tr class="memdesc:gaa59866fd485a59868a2a594a5858f1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for #mcuxClMath_ModInv.  <a href="#gaa59866fd485a59868a2a594a5858f1de">More...</a><br /></td></tr>
<tr class="separator:gaa59866fd485a59868a2a594a5858f1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab456571414ef2f49a91b61f0c91009ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gab456571414ef2f49a91b61f0c91009ba">MCUXCLMATH_FP_MODINV</a>(iR,  iX,  iN,  iT)</td></tr>
<tr class="memdesc:gab456571414ef2f49a91b61f0c91009ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for #mcuxClMath_ModInv with flow protection.  <a href="#gab456571414ef2f49a91b61f0c91009ba">More...</a><br /></td></tr>
<tr class="separator:gab456571414ef2f49a91b61f0c91009ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ee39987ba7de0e36abc848d77b4eaa3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga3ee39987ba7de0e36abc848d77b4eaa3">MCUXCLMATH_REDUCEMODEVEN</a>(iR,  iX,  iN,  iT0,  iT1,  iT2,  iT3)</td></tr>
<tr class="memdesc:ga3ee39987ba7de0e36abc848d77b4eaa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for #mcuxClMath_ReduceModEven.  <a href="#ga3ee39987ba7de0e36abc848d77b4eaa3">More...</a><br /></td></tr>
<tr class="separator:ga3ee39987ba7de0e36abc848d77b4eaa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed2b24ff10b916eb07a842a2a05ad341"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gaed2b24ff10b916eb07a842a2a05ad341">MCUXCLMATH_FP_REDUCEMODEVEN</a>(iR,  iX,  iN,  iT0,  iT1,  iT2,  iT3)</td></tr>
<tr class="memdesc:gaed2b24ff10b916eb07a842a2a05ad341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for #mcuxClMath_ReduceModEven with flow protection.  <a href="#gaed2b24ff10b916eb07a842a2a05ad341">More...</a><br /></td></tr>
<tr class="separator:gaed2b24ff10b916eb07a842a2a05ad341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82842f4b45c0d86e4c2d6d29e23c259b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga82842f4b45c0d86e4c2d6d29e23c259b">MCUXCLMATH_MODEXP_SQRMULTL2R</a>(pExp,  byteLenExp,  iR,  iX,  iN,  iT)</td></tr>
<tr class="memdesc:ga82842f4b45c0d86e4c2d6d29e23c259b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for #mcuxClMath_ModExp_SqrMultL2R.  <a href="#ga82842f4b45c0d86e4c2d6d29e23c259b">More...</a><br /></td></tr>
<tr class="separator:ga82842f4b45c0d86e4c2d6d29e23c259b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f0c8d67f0c192341fbf9ac436f02173"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga9f0c8d67f0c192341fbf9ac436f02173">MCUXCLMATH_FP_MODEXP_SQRMULTL2R</a>(pExp,  byteLenExp,  iR,  iX,  iN,  iT)</td></tr>
<tr class="memdesc:ga9f0c8d67f0c192341fbf9ac436f02173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for #mcuxClMath_ModExp_SqrMultL2R with flow protection.  <a href="#ga9f0c8d67f0c192341fbf9ac436f02173">More...</a><br /></td></tr>
<tr class="separator:ga9f0c8d67f0c192341fbf9ac436f02173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e0168ff93f7bffd7d56ce509ba29c59"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga3e0168ff93f7bffd7d56ce509ba29c59">MCUXCLMATH_SECMODEXP</a>(session,  pExp,  pExpTemp,  byteLenExp,  iR,  iX,  iN,  iTE,  iT0,  iT1,  iT2,  iT3)</td></tr>
<tr class="memdesc:ga3e0168ff93f7bffd7d56ce509ba29c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for #mcuxClMath_SecModExp.  <a href="#ga3e0168ff93f7bffd7d56ce509ba29c59">More...</a><br /></td></tr>
<tr class="separator:ga3e0168ff93f7bffd7d56ce509ba29c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32eaa55458996d636a82ac9bda34e3e0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga32eaa55458996d636a82ac9bda34e3e0">MCUXCLMATH_SECMODEXP_WITHOUT_RERANDOMIZATION</a>(session,  pExp,  pExpTemp,  byteLenExp,  iR,  iX,  iN,  iTE,  iT0,  iT1,  iT2,  iT3)</td></tr>
<tr class="memdesc:ga32eaa55458996d636a82ac9bda34e3e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for #mcuxClMath_SecModExp with disabled operand re-randomization.  <a href="#ga32eaa55458996d636a82ac9bda34e3e0">More...</a><br /></td></tr>
<tr class="separator:ga32eaa55458996d636a82ac9bda34e3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae807c4ed789f67aa150addbae31de180"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gae807c4ed789f67aa150addbae31de180">MCUXCLMATH_EXACTDIVIDEODD</a>(iR,  iX,  iN,  iT,  xPkcByteLen,  yPkcByteLen)</td></tr>
<tr class="memdesc:gae807c4ed789f67aa150addbae31de180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for #mcuxClMath_ExactDivideOdd.  <a href="#gae807c4ed789f67aa150addbae31de180">More...</a><br /></td></tr>
<tr class="separator:gae807c4ed789f67aa150addbae31de180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1d62616daa224745d2ed40fdfa4d724"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gaf1d62616daa224745d2ed40fdfa4d724">MCUXCLMATH_FP_EXACTDIVIDEODD</a>(iR,  iX,  iN,  iT,  xPkcByteLen,  yPkcByteLen)</td></tr>
<tr class="memdesc:gaf1d62616daa224745d2ed40fdfa4d724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for #mcuxClMath_ExactDivideOdd with flow protection.  <a href="#gaf1d62616daa224745d2ed40fdfa4d724">More...</a><br /></td></tr>
<tr class="separator:gaf1d62616daa224745d2ed40fdfa4d724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae99e5e55dda4387e4384e974a112a760"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gae99e5e55dda4387e4384e974a112a760">MCUXCLMATH_EXACTDIVIDE</a>(iR,  iX,  iN,  iT,  xPkcByteLen,  yPkcByteLen)</td></tr>
<tr class="memdesc:gae99e5e55dda4387e4384e974a112a760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for #mcuxClMath_ExactDivide.  <a href="#gae99e5e55dda4387e4384e974a112a760">More...</a><br /></td></tr>
<tr class="separator:gae99e5e55dda4387e4384e974a112a760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dd21ea08b92f104bd3d9bff5ce7efe7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#ga4dd21ea08b92f104bd3d9bff5ce7efe7">MCUXCLMATH_FP_EXACTDIVIDE</a>(iR,  iX,  iN,  iT,  xPkcByteLen,  yPkcByteLen)</td></tr>
<tr class="memdesc:ga4dd21ea08b92f104bd3d9bff5ce7efe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for #mcuxClMath_ExactDivide with flow protection.  <a href="#ga4dd21ea08b92f104bd3d9bff5ce7efe7">More...</a><br /></td></tr>
<tr class="separator:ga4dd21ea08b92f104bd3d9bff5ce7efe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf05d42c37f836335f81035bde1b5c2bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gaf05d42c37f836335f81035bde1b5c2bb">MCUX_CSSL_FP_PROTECTED_TYPE</a> (void) mcuxClMath_InitLocalUptrt(uint32_t i3_i2_i1_i0</td></tr>
<tr class="memdesc:gaf05d42c37f836335f81035bde1b5c2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes and uses the new UPTRT and returns the address of original UPTRT.  <a href="#gaf05d42c37f836335f81035bde1b5c2bb">More...</a><br /></td></tr>
<tr class="separator:gaf05d42c37f836335f81035bde1b5c2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf40f87ea9a6016cd444733991730d35d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mcux_cl_math___functions.html#gaf40f87ea9a6016cd444733991730d35d">MCUX_CSSL_FP_PROTECTED_TYPE</a> (uint32_t) mcuxClMath_TrailingZeros(uint8_t iX)</td></tr>
<tr class="memdesc:gaf40f87ea9a6016cd444733991730d35d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts number of trailing zero bits of a PKC operand.  <a href="#gaf40f87ea9a6016cd444733991730d35d">More...</a><br /></td></tr>
<tr class="separator:gaf40f87ea9a6016cd444733991730d35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaf1ef73e520ed312fd475a628b99a20ec"><td class="memItemLeft" align="right" valign="top"><a id="gaf1ef73e520ed312fd475a628b99a20ec"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>i7_i6_i5_i4</b></td></tr>
<tr class="separator:gaf1ef73e520ed312fd475a628b99a20ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga925eddae0ef20ee656588876029b8092"><td class="memItemLeft" align="right" valign="top"><a id="ga925eddae0ef20ee656588876029b8092"></a>
uint32_t uint16_t *&#160;</td><td class="memItemRight" valign="bottom"><b>localPtrUptrt</b></td></tr>
<tr class="separator:ga925eddae0ef20ee656588876029b8092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a7d76114d47ce637ad1947ad018a13e"><td class="memItemLeft" align="right" valign="top"><a id="ga3a7d76114d47ce637ad1947ad018a13e"></a>
uint32_t uint16_t uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>noOfIndices</b></td></tr>
<tr class="separator:ga3a7d76114d47ce637ad1947ad018a13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3a0ca4c2a03da5451ce6bcfcedfcd10"><td class="memItemLeft" align="right" valign="top"><a id="gab3a0ca4c2a03da5451ce6bcfcedfcd10"></a>
uint32_t uint16_t uint8_t const uint16_t **&#160;</td><td class="memItemRight" valign="bottom"><b>oldPtrUptrt</b></td></tr>
<tr class="separator:gab3a0ca4c2a03da5451ce6bcfcedfcd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf181ae59c982598bf57427a15a8be411"><td class="memItemLeft" align="right" valign="top"><a id="gaf181ae59c982598bf57427a15a8be411"></a>
uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><b>pNumLeadingZeros</b></td></tr>
<tr class="separator:gaf181ae59c982598bf57427a15a8be411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1892eba2086d12ac2b09005aeb09ea3b"><td class="memItemLeft" align="right" valign="top"><a id="ga1892eba2086d12ac2b09005aeb09ea3b"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>length</b></td></tr>
<tr class="separator:ga1892eba2086d12ac2b09005aeb09ea3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19c0795bafea7dc12049ca68553d1502"><td class="memItemLeft" align="right" valign="top"><a id="ga19c0795bafea7dc12049ca68553d1502"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>iT1_iT2_iT3</b></td></tr>
<tr class="separator:ga19c0795bafea7dc12049ca68553d1502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b4ea15275874f910cb99e2430ca5e54"><td class="memItemLeft" align="right" valign="top"><a id="ga1b4ea15275874f910cb99e2430ca5e54"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>expByteLength</b></td></tr>
<tr class="separator:ga1b4ea15275874f910cb99e2430ca5e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b46696154c14a1c2e8a20272a6e2f35"><td class="memItemLeft" align="right" valign="top"><a id="ga6b46696154c14a1c2e8a20272a6e2f35"></a>
uint32_t uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>iR_iX_iN_iT</b></td></tr>
<tr class="separator:ga6b46696154c14a1c2e8a20272a6e2f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e9dde1324099335da288945a22be675"><td class="memItemLeft" align="right" valign="top"><a id="ga4e9dde1324099335da288945a22be675"></a>
const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>pExp</b></td></tr>
<tr class="separator:ga4e9dde1324099335da288945a22be675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e15edbb95af11c4f4094b4bedc67fbb"><td class="memItemLeft" align="right" valign="top"><a id="ga0e15edbb95af11c4f4094b4bedc67fbb"></a>
const uint8_t uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><b>pExpTemp</b></td></tr>
<tr class="separator:ga0e15edbb95af11c4f4094b4bedc67fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bc1e7401d14e5e7cec2a163842e3f00"><td class="memItemLeft" align="right" valign="top"><a id="ga0bc1e7401d14e5e7cec2a163842e3f00"></a>
const uint8_t uint32_t uint32_t uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>iT3_iX_iT2_iT1</b></td></tr>
<tr class="separator:ga0bc1e7401d14e5e7cec2a163842e3f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f82dd238ffc2bcc89aba9218e1b5499"><td class="memItemLeft" align="right" valign="top"><a id="ga7f82dd238ffc2bcc89aba9218e1b5499"></a>
const uint8_t uint32_t uint32_t uint32_t uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>iN_iTE_iT0_iR</b></td></tr>
<tr class="separator:ga7f82dd238ffc2bcc89aba9218e1b5499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d2cd4a5c86c5b160e55bdf0107e7915"><td class="memItemLeft" align="right" valign="top"><a id="ga3d2cd4a5c86c5b160e55bdf0107e7915"></a>
const uint8_t uint32_t uint32_t uint32_t uint32_t uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>secOption</b></td></tr>
<tr class="separator:ga3d2cd4a5c86c5b160e55bdf0107e7915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6e7ed3fb4da819a702256aae0c27cd7"><td class="memItemLeft" align="right" valign="top"><a id="gae6e7ed3fb4da819a702256aae0c27cd7"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>xPkcByteLength</b></td></tr>
<tr class="separator:gae6e7ed3fb4da819a702256aae0c27cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd774555389055fde6e9e58ef95273c4"><td class="memItemLeft" align="right" valign="top"><a id="gafd774555389055fde6e9e58ef95273c4"></a>
uint32_t uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>yPkcByteLength</b></td></tr>
<tr class="separator:gafd774555389055fde6e9e58ef95273c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Defines all functions of <a class="el" href="group__mcux_cl_math.html">mcuxClMath</a>. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaadd4485b0f1db32b6da6e6b7a2e6cc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadd4485b0f1db32b6da6e6b7a2e6cc11">&#9670;&nbsp;</a></span>MCUXCLMATH_SHIFTMODULUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_SHIFTMODULUS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iNShifted, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for #mcuxClMath_ShiftModulus. </p>

</div>
</div>
<a id="ga35df7cdad4c81c5e276f373c70c571d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35df7cdad4c81c5e276f373c70c571d0">&#9670;&nbsp;</a></span>MCUXCLMATH_FP_SHIFTMODULUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_SHIFTMODULUS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iNShifted, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for #mcuxClMath_ShiftModulus with flow protection. </p>

</div>
</div>
<a id="gab588855e23f750a4c9f7533b54a11325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab588855e23f750a4c9f7533b54a11325">&#9670;&nbsp;</a></span>MCUXCLMATH_NDASH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_NDASH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for #mcuxClMath_NDash. </p>

</div>
</div>
<a id="gafa0d390f4eb5728edfd764936aeee313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa0d390f4eb5728edfd764936aeee313">&#9670;&nbsp;</a></span>MCUXCLMATH_FP_NDASH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_NDASH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for #mcuxClMath_NDash with flow protection. </p>

</div>
</div>
<a id="ga666d3347d6f96a09b791355e596de46d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga666d3347d6f96a09b791355e596de46d">&#9670;&nbsp;</a></span>MCUXCLMATH_QDASH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_QDASH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iQDash, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iNShifted, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for #mcuxClMath_QDash. </p>

</div>
</div>
<a id="ga7703703d552c5446acdf38d82cd81971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7703703d552c5446acdf38d82cd81971">&#9670;&nbsp;</a></span>MCUXCLMATH_FP_QDASH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_QDASH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iQDash, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iNShifted, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for #mcuxClMath_QDash with flow protection. </p>

</div>
</div>
<a id="ga4ee6d9b078ecc35a081a3a8cdbec0968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ee6d9b078ecc35a081a3a8cdbec0968">&#9670;&nbsp;</a></span>MCUXCLMATH_QSQUARED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_QSQUARED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iQSqr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iNShifted, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for #mcuxClMath_QSquared. </p>

</div>
</div>
<a id="gadcd348426e9998703dc6f93194a62f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcd348426e9998703dc6f93194a62f80">&#9670;&nbsp;</a></span>MCUXCLMATH_FP_QSQUARED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_QSQUARED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iQSqr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iNShifted, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for #mcuxClMath_QSquared with flow protection. </p>

</div>
</div>
<a id="gaa59866fd485a59868a2a594a5858f1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa59866fd485a59868a2a594a5858f1de">&#9670;&nbsp;</a></span>MCUXCLMATH_MODINV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_MODINV</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for #mcuxClMath_ModInv. </p>

</div>
</div>
<a id="gab456571414ef2f49a91b61f0c91009ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab456571414ef2f49a91b61f0c91009ba">&#9670;&nbsp;</a></span>MCUXCLMATH_FP_MODINV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_MODINV</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for #mcuxClMath_ModInv with flow protection. </p>

</div>
</div>
<a id="ga3ee39987ba7de0e36abc848d77b4eaa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ee39987ba7de0e36abc848d77b4eaa3">&#9670;&nbsp;</a></span>MCUXCLMATH_REDUCEMODEVEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_REDUCEMODEVEN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT0, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT3&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for #mcuxClMath_ReduceModEven. </p>

</div>
</div>
<a id="gaed2b24ff10b916eb07a842a2a05ad341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed2b24ff10b916eb07a842a2a05ad341">&#9670;&nbsp;</a></span>MCUXCLMATH_FP_REDUCEMODEVEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_REDUCEMODEVEN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT0, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT3&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for #mcuxClMath_ReduceModEven with flow protection. </p>

</div>
</div>
<a id="ga82842f4b45c0d86e4c2d6d29e23c259b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82842f4b45c0d86e4c2d6d29e23c259b">&#9670;&nbsp;</a></span>MCUXCLMATH_MODEXP_SQRMULTL2R</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_MODEXP_SQRMULTL2R</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pExp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">byteLenExp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for #mcuxClMath_ModExp_SqrMultL2R. </p>

</div>
</div>
<a id="ga9f0c8d67f0c192341fbf9ac436f02173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f0c8d67f0c192341fbf9ac436f02173">&#9670;&nbsp;</a></span>MCUXCLMATH_FP_MODEXP_SQRMULTL2R</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_MODEXP_SQRMULTL2R</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pExp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">byteLenExp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for #mcuxClMath_ModExp_SqrMultL2R with flow protection. </p>

</div>
</div>
<a id="ga3e0168ff93f7bffd7d56ce509ba29c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e0168ff93f7bffd7d56ce509ba29c59">&#9670;&nbsp;</a></span>MCUXCLMATH_SECMODEXP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_SECMODEXP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">session, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pExp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pExpTemp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">byteLenExp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iTE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT0, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT3&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for #mcuxClMath_SecModExp. </p>

</div>
</div>
<a id="ga32eaa55458996d636a82ac9bda34e3e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32eaa55458996d636a82ac9bda34e3e0">&#9670;&nbsp;</a></span>MCUXCLMATH_SECMODEXP_WITHOUT_RERANDOMIZATION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_SECMODEXP_WITHOUT_RERANDOMIZATION</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">session, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pExp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pExpTemp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">byteLenExp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iTE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT0, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT3&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for #mcuxClMath_SecModExp with disabled operand re-randomization. </p>
<p>TODO CLNS-7824: analyze how to use the SecModExp in RsaKg MillerRabinTest, and remove secOption to always re-randomize </p>

</div>
</div>
<a id="gae807c4ed789f67aa150addbae31de180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae807c4ed789f67aa150addbae31de180">&#9670;&nbsp;</a></span>MCUXCLMATH_EXACTDIVIDEODD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_EXACTDIVIDEODD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xPkcByteLen, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">yPkcByteLen&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for #mcuxClMath_ExactDivideOdd. </p>

</div>
</div>
<a id="gaf1d62616daa224745d2ed40fdfa4d724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1d62616daa224745d2ed40fdfa4d724">&#9670;&nbsp;</a></span>MCUXCLMATH_FP_EXACTDIVIDEODD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_EXACTDIVIDEODD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xPkcByteLen, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">yPkcByteLen&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for #mcuxClMath_ExactDivideOdd with flow protection. </p>

</div>
</div>
<a id="gae99e5e55dda4387e4384e974a112a760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae99e5e55dda4387e4384e974a112a760">&#9670;&nbsp;</a></span>MCUXCLMATH_EXACTDIVIDE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_EXACTDIVIDE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xPkcByteLen, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">yPkcByteLen&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for #mcuxClMath_ExactDivide. </p>

</div>
</div>
<a id="ga4dd21ea08b92f104bd3d9bff5ce7efe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dd21ea08b92f104bd3d9bff5ce7efe7">&#9670;&nbsp;</a></span>MCUXCLMATH_FP_EXACTDIVIDE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_EXACTDIVIDE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xPkcByteLen, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">yPkcByteLen&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for #mcuxClMath_ExactDivide with flow protection. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf05d42c37f836335f81035bde1b5c2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf05d42c37f836335f81035bde1b5c2bb">&#9670;&nbsp;</a></span>MCUX_CSSL_FP_PROTECTED_TYPE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MCUX_CSSL_FP_PROTECTED_TYPE </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes and uses the new UPTRT and returns the address of original UPTRT. </p>
<p>Wait until PKC is ready to accept new calculation.</p>
<p>Wait until PKC finishes calculations.</p>
<p>Start a PKC FUP program calculation.</p>
<p>Start a PKC calculation with one constant parameter.</p>
<p>Start a PKC calculation.</p>
<p>Initialize UPTR table.</p>
<p>deinitialize PKC hardware</p>
<p>Calculates exact division (supporting even divisor).</p>
<p>Calculates exact division with odd divisor.</p>
<p>Calculates modular exponentiation.</p>
<p>Calculates modular reduction with even modulus.</p>
<p>Calculates modular inversion, with odd modulus.</p>
<p>Calculates QSquared = Q^2 mod n, where Q = 256^(operandSize) mod n.</p>
<p>Calculates QDash = Q * Q' mod n, where Q = 256^(operandSize) mod n, and Q' = 256^length mod n.</p>
<p>Prepares modulus (calculates NDash) for PKC modular multiplication.</p>
<p>Prepares shifted modulus.</p>
<p>Counts number of leading zero bits of a PKC operand.</p>
<p>This function copies up to 8 offsets of PKC operands from current UPTRT to the new UPTRT, sets PKC to use the new UPTRT, and returns the address of original UPTRT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i3_i2_i1_i0</td><td>the first 4 indices of offsets to be copied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i7_i6_i5_i4</td><td>the second 4 indices of offsets to be copied </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">localPtrUptrt</td><td>address of the new UPTRT to be filled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noOfIndices</td><td>number of offsets to be copied from original UPTRT to new UPTRT </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">oldPtrUptrt</td><td>pointer to where receives the original UPTRT address</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>i3_i2_i1_i0</code>  </dt>
<dd><code>i0</code> (bits 0~7): originalUptrt[i0] will be copied to <code>localPtrUptrt</code>[0], if <code>noOfIndices</code> &gt;= 1. <br />
<code>i1</code> (bits 8~15): originalUptrt[i1] will be copied to <code>localPtrUptrt</code>[1], if <code>noOfIndices</code> &gt;= 2. <br />
<code>i2</code> (bits 16~23): originalUptrt[i2] will be copied to <code>localPtrUptrt</code>[2], if <code>noOfIndices</code> &gt;= 3. <br />
<code>i3</code> (bits 24~31): originalUptrt[i3] will be copied to <code>localPtrUptrt</code>[3], if <code>noOfIndices</code> &gt;= 4. </dd>
<dt><code>i7_i6_i5_i4</code>  </dt>
<dd><code>i4</code> (bits 0~7): originalUptrt[i4] will be copied to <code>localPtrUptrt</code>[4], if <code>noOfIndices</code> &gt;= 5. <br />
<code>i5</code> (bits 8~15): originalUptrt[i5] will be copied to <code>localPtrUptrt</code>[5], if <code>noOfIndices</code> &gt;= 6. <br />
<code>i6</code> (bits 16~23): originalUptrt[i6] will be copied to <code>localPtrUptrt</code>[6], if <code>noOfIndices</code> &gt;= 7. <br />
<code>i7</code> (bits 24~31): originalUptrt[i7] will be copied to <code>localPtrUptrt</code>[7], if <code>noOfIndices</code> &gt;= 8. </dd>
<dt><code>localPtrUptrt</code>  </dt>
<dd>This address shall be 2-byte aligned. <br />
Caller shall allocate at least <code>noOfIndices</code> 2-byte entries in this table. </dd>
</dl>
</dd>
</dl>
<dl>
<dt>PKC properties </dt>
<dd><dl>
<dt>UPTRT </dt>
<dd>This function will retrieve the original UPTRT address and return it to caller via <code>oldPtrUptrt</code>. <br />
This function will overwrite this address by <code>localPtrUptrt</code>. </dd>
<dt>PS1 lengths </dt>
<dd>Unused. </dd>
<dt>PS2 lengths </dt>
<dd>Unused. </dd>
<dt>ACTIV/GOANY </dt>
<dd>This function shall not be called during a running FUP program (i.e., GOANY bit is set). Caller shall call #mcuxClPkc_WaitForReady before calling this function, if a FUP program has been called. </dd>
</dl>
</dd>
</dl>
<p>This function counts the number of leading zero bits of a PKC operand at offset UPTRT[iX] and of size PS1 OPLEN.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iX</td><td>index of PKC operand </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pNumLeadingZeros</td><td>pointer to where the number of leading zero bits will be stored</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>iX</code>  </dt>
<dd>index of X (PKC operand), size = operandSize. <br />
The offset (UPTRT[iX]) shall be exactly a multiple of MCUXCLPKC_WORDSIZE. </dd>
</dl>
</dd>
</dl>
<dl>
<dt>PKC properties </dt>
<dd><dl>
<dt>PS1 lengths </dt>
<dd>PS1 OPLEN defines operandSize and shall be exactly a multiple of MCUXCLPKC_WORDSIZE. </dd>
<dt>PS2 lengths </dt>
<dd>Unused. </dd>
<dt>ACTIV/GOANY </dt>
<dd>This function will not use PKC, and assumes PKC will not modify the operand iX simultaneously. </dd>
</dl>
</dd>
</dl>
<p>This function left shifts modulus (PKC operand iN) until there is no leading zero and stores the result in PKC operand iNShifted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iNShifted_iN</td><td>indices of PKC operands</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>iNShifted_iN</code>  </dt>
<dd><code>iN</code> (bits 0~7): index of modulus (PKC operand), size = operandSize. <br />
The modulus shall be non-zero. <br />
The offset (UPTRT[iN]) shall be exactly a multiple of MCUXCLPKC_WORDSIZE. <br />
<code>iNShifted</code> (bits 8~15): index of shifted modulus (PKC operand), size = operandSize. <br />
This function supports in-place operation, i.e., iNShifted = iN. </dd>
</dl>
</dd>
</dl>
<dl>
<dt>PKC properties </dt>
<dd><dl>
<dt>PS1 lengths </dt>
<dd>PS1 OPLEN defines operandSize and shall be exactly a multiple of MCUXCLPKC_WORDSIZE. </dd>
<dt>PS2 lengths </dt>
<dd>PS2 OPLEN and MCLEN will be modified, and original values will not be restored. </dd>
<dt>ACTIV/GOANY </dt>
<dd>The PKC calculation might be still on-going, call #mcuxClPkc_WaitForFinish before CPU accesses to the result. </dd>
</dl>
</dd>
</dl>
<p>This function calculates NDash = (-modulus)^(-1) mod 256^(MCUXCLPKC_WORDSIZE) and stores NDash in the PKC word in front of the PKC operand of modulus (iN).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iN_iT</td><td>indices of PKC operands</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>iN_iT</code>  </dt>
<dd><code>iT</code> (bits 0~7): index of temp (PKC operand). <br />
The size of temp shall be at least (2 * MCUXCLPKC_WORDSIZE). <br />
<code>iN</code> (bits 8~15): index of modulus (PKC operand). <br />
The modulus shall be an odd number. <br />
The result NDash will be stored in the PKC word before modulus, i.e., at the offset, (UPTRT[iN] - MCUXCLPKC_WORDSIZE). </dd>
</dl>
</dd>
</dl>
<dl>
<dt>PKC properties </dt>
<dd><dl>
<dt>PS1 lengths </dt>
<dd>Unused. </dd>
<dt>PS2 lengths </dt>
<dd>PS2 OPLEN and MCLEN will be modified, and original values will not be restored. </dd>
<dt>ACTIV/GOANY </dt>
<dd>#mcuxClPkc_WaitForReady will be called before returning to caller. <br />
The PKC calculation might be still on-going, call #mcuxClPkc_WaitForFinish before CPU accesses to the result. </dd>
</dl>
</dd>
</dl>
<p>This function computes QDash which can be used to convert a PKC operand (of the size <code>length</code>) to its Montgomery representation (of the size operandSize).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iQDash_iNShifted_iN_iT</td><td>indices of PKC operands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>specify Q' = 256^length mod n</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>iQDash_iNShifted_iN_iT</code>  </dt>
<dd><code>iT</code> (bits 0~7): index of temp (PKC operand). <br />
The size of temp shall be at least (operandSize + MCUXCLPKC_WORDSIZE). <br />
<code>iN</code> (bits 8~15): index of modulus (PKC operand), size = operandSize. <br />
NDash of modulus shall be stored in the PKC word before modulus. <br />
<code>iNShifted</code> (bits 16~23): index of shifted modulus (PKC operand), size = operandSize. <br />
If there is no leading zero in the PKC operand modulus, it can be iN. <br />
<code>iQDash</code> (bits 24~31): index of result QDash (PKC operand), size = operandSize. <br />
QDash might be greater than modulus. </dd>
<dt><code>length</code>  </dt>
<dd>It shall be nonzero. A zero length will cause undefined behavior. </dd>
</dl>
</dd>
</dl>
<dl>
<dt>PKC properties </dt>
<dd><dl>
<dt>PS1 lengths </dt>
<dd>PS1 OPLEN = MCLEN defines operandSize. </dd>
<dt>PS2 lengths </dt>
<dd>Unused. </dd>
<dt>ACTIV/GOANY </dt>
<dd>#mcuxClPkc_WaitForReady will be called before returning to caller. <br />
The PKC calculation might be still on-going, call #mcuxClPkc_WaitForFinish before CPU accesses to the result. </dd>
</dl>
</dd>
</dl>
<p>This function computes QSquared which can be used to convert a PKC operand to its Montgomery representation (both are of the size operandSize).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iQSqr_iNShifted_iN_iT</td><td>indices of PKC operands</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>iQSqr_iNShifted_iN_iT</code>  </dt>
<dd><code>iT</code> (bits 0~7): index of temp (PKC operand). <br />
The size of temp shall be at least (operandSize + MCUXCLPKC_WORDSIZE). <br />
<code>iN</code> (bits 8~15): index of modulus (PKC operand), size = operandSize. <br />
NDash of modulus shall be stored in the PKC word before modulus. <br />
<code>iNShifted</code> (bits 16~23): index of shifted modulus (PKC operand), size = operandSize. <br />
If there is no leading zero in the PKC operand modulus, it can be iN. <br />
<code>iQSqr</code> (bits 24~31): index of result QSquared (PKC operand), size = operandSize. <br />
QSquared might be greater than modulus. </dd>
</dl>
</dd>
</dl>
<dl>
<dt>PKC properties </dt>
<dd><dl>
<dt>PS1 lengths </dt>
<dd>PS1 OPLEN = MCLEN defines operandSize and shall be exactly a multiple of MCUXCLPKC_WORDSIZE. </dd>
<dt>PS2 lengths </dt>
<dd>Unused. </dd>
<dt>ACTIV/GOANY </dt>
<dd>#mcuxClPkc_WaitForReady will be called before returning to caller. <br />
The PKC calculation might be still on-going, call #mcuxClPkc_WaitForFinish before CPU accesses to the result. </dd>
</dl>
</dd>
</dl>
<p>This function calculates modular inversion, result = X^(-1) mod n.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iR_iX_iN_iT</td><td>indices of PKC operands</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>iR_iX_iN_iT</code>  </dt>
<dd><code>iT</code> (bits 0~7): index of temp (PKC operand). <br />
Its size shall be at least (operandSize + MCUXCLPKC_WORDSIZE). <br />
The offset (UPTRT[iT]) shall be exactly a multiple of MCUXCLPKC_WORDSIZE. <br />
<code>iN</code> (bits 8~15): index of modulus (PKC operand), size = operandSize. <br />
NDash of modulus shall be stored in the PKC word before modulus. <br />
<code>iX</code> (bits 16~23): index of X (PKC operand), size = operandSize. <br />
X will be destroyed by this function. <br />
X and the modulus shall be coprime, otherwise the result will be incorrect. <br />
<code>iR</code> (bits 24~31): index of result (PKC operand). <br />
Its size shall be at least (operandSize + MCUXCLPKC_WORDSIZE). <br />
The offset (UPTRT[iR]) shall be exactly a multiple of MCUXCLPKC_WORDSIZE. <br />
The result fits in operandSize, but might be greater than modulus. </dd>
</dl>
</dd>
</dl>
<dl>
<dt>PKC properties </dt>
<dd><dl>
<dt>PS1 lengths </dt>
<dd>PS1 OPLEN = MCLEN defines operandSize. </dd>
<dt>PS2 lengths </dt>
<dd>PS2 OPLEN and MCLEN will be modified, and original values will not be restored. </dd>
<dt>ACTIV/GOANY </dt>
<dd>#mcuxClPkc_WaitForReady will be called before returning to caller. <br />
The PKC calculation might be still on-going, call #mcuxClPkc_WaitForFinish before CPU accesses to the result. </dd>
</dl>
</dd>
</dl>
<p>This function calculates modular reduction result = X mod n, where the modulus n is even.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iR_iX_iN_iT0</td><td>indices of PKC operands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iT1_iT2_iT3</td><td>indices of PKC operands</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>iR_iX_iN_iT0</code>  </dt>
<dd><code>iT0</code> (bits 0~7): index of temp0 (PKC operand). <br />
Its size shall be at least (lenN + MCUXCLPKC_WORDSIZE). <br />
The operand of modulus can be used as temp0 (i.e., iT0 = iN), but the modulus will be destroyed. <br />
<code>iN</code> (bits 8~15): index of modulus (PKC operand), size = lenN. <br />
The offset (UPTRT[iN]) shall be exactly a multiple of MCUXCLPKC_WORDSIZE. <br />
<code>iX</code> (bits 16~23): index of X (PKC operand). <br />
Its size shall be at least (lenX + MCUXCLPKC_WORDSIZE). <br />
<code>iR</code> (bits 24~31): index of result (PKC operand). <br />
Its size shall be at least (lenN + MCUXCLPKC_WORDSIZE). </dd>
<dt><code>iT1_iT2_iT3</code>  </dt>
<dd><code>iT3</code> (bits 0~7): index of temp3 (PKC operand). <br />
Its size shall be at least (lenN + MCUXCLPKC_WORDSIZE). <br />
<code>iT2</code> (bits 8~15): index of temp2 (PKC operand). <br />
Its size shall be at least lenN. <br />
<code>iT1</code> (bits 16~23): index of temp1 (PKC operand). <br />
Its size shall be at least lenN. <br />
The operand of result can be used as temp1 (i.e., iT1 = iR). TODO: always use R (any reason not using R?) </dd>
</dl>
</dd>
</dl>
<dl>
<dt>PKC properties </dt>
<dd><dl>
<dt>PS1 lengths </dt>
<dd>PS1 OPLEN defines lenN (length of modulus n), and MCLEN defines lenX (length of X). <br />
Both OPLEN and MCLEN shall be exactly a multiple of MCUXCLPKC_WORDSIZE. </dd>
<dt>PS2 lengths </dt>
<dd>PS2 OPLEN and MCLEN will be modified, and original values will not be restored. </dd>
<dt>ACTIV/GOANY </dt>
<dd>#mcuxClPkc_WaitForReady will be called before returning to caller. <br />
The PKC calculation might be still on-going, call #mcuxClPkc_WaitForFinish before CPU accesses to the result. </dd>
</dl>
</dd>
</dl>
<p>This function calculates modular exponentiation with left-to-right binary square-and-multiply algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pExp</td><td>pointer to exponent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expByteLength</td><td>byte length of exponent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iR_iX_iN_iT</td><td>indices of PKC operands</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>pExp</code>  </dt>
<dd>the exponent is a big-endian octet string and shall be non-zero. </dd>
<dt><code>iR_iX_iN_iT</code>  </dt>
<dd><code>iT</code> (bits 0~7): index of temp operand (PKC operand). <br />
Its size shall be at least (lenN + MCUXCLPKC_WORDSIZE). <br />
<code>iN</code> (bits 8~15): index of modulus (PKC operand), size = operandSize. <br />
NDash of modulus shall be stored in the PKC word before modulus. <br />
<code>iX</code> (bits 16~23): index of base number (PKC operand), size = operandSize. <code>iR</code> (bits 24~31): index of result (PKC operand). <br />
Its size shall be at least (lenN + MCUXCLPKC_WORDSIZE). </dd>
</dl>
</dd>
</dl>
<dl>
<dt>PKC properties </dt>
<dd><dl>
<dt>PS1 lengths </dt>
<dd>PS1 OPLEN = MCLEN defines operandSize. </dd>
<dt>PS2 lengths </dt>
<dd>Unused. </dd>
<dt>ACTIV/GOANY </dt>
<dd>The PKC calculation might be still on-going, call #mcuxClPkc_WaitForFinish before CPU accesses to the result. </dd>
</dl>
</dd>
</dl>
<p>This function calculates exact division R = X/Y, where divisor Y is odd and dividend X shall be exactly a multiple of Y. If X is not a multiple of Y, result will be incorrect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iR_iX_iY_iT</td><td>indices of PKC operands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xPkcByteLength</td><td>length of X </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yPkcByteLength</td><td>length of Y</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>iR_iX_iY_iT</code>  </dt>
<dd><code>iT</code> (bits 0~7): index of temp (PKC operand). <br />
Its size shall be at least (3 * MCUXCLPKC_WORDSIZE). <br />
The offset (UPTRT[iT]) shall be exactly a multiple of MCUXCLPKC_WORDSIZE. <br />
<code>iY</code> (bits 8~15): index of divisor Y (PKC operand), size = yPkcByteLength. <br />
The most significant PKC word of Y shall be nonzero. <br />
<code>iX</code> (bits 16~23): index of dividend X (PKC operand), size = xPkcByteLength. <br />
X will be destroyed by this function. <br />
CAUTION: if xPkcByteLength = MCUXCLPKC_WORDSIZE, this function will access to (read) one extra PKC word of X, i.e., X[MCUXCLPKC_WORDSIZE ~ 2*MCUXCLPKC_WORDSIZE - 1]. The value of this PKC word will not affect correctness of the result, but caller shall ensure that this PKC word is accessible by PKC. <br />
<code>iR</code> (bits 24~31): index of result R (PKC operand), size = (xPkcByteLength - yPkcByteLength + MCUXCLPKC_WORDSIZE). </dd>
<dt><code>xPkcByteLength</code>  </dt>
<dd>It shall be a multiple of MCUXCLPKC_WORDSIZE. </dd>
<dt><code>yPkcByteLength</code>  </dt>
<dd>It shall be a multiple of MCUXCLPKC_WORDSIZE. </dd>
</dl>
</dd>
</dl>
<dl>
<dt>PKC properties </dt>
<dd><dl>
<dt>PS1 lengths </dt>
<dd>Unused (modified and restored in the function). </dd>
<dt>PS2 lengths </dt>
<dd>PS2 OPLEN and MCLEN will be modified, and original values will not be restored. </dd>
<dt>ACTIV/GOANY </dt>
<dd>#mcuxClPkc_WaitForReady will be called before returning to caller. <br />
The PKC calculation might be still on-going, call #mcuxClPkc_WaitForFinish before CPU accesses to the result. </dd>
</dl>
</dd>
</dl>
<p>This function calculates exact division R = X/Y, where dividend X shall be exactly a multiple of divisor Y. If X is not a multiple of Y, result will be incorrect.</p>
<p>This function trims trailing zero bits of Y and gets Y' = Y &gt;&gt; trailingZeros(Y), and X' = X &gt;&gt; ((trailingZeros(Y) / 8*MCUXCLPKC_WORDSIZE) * 8*MCUXCLPKC_WORDSIZE). It relies on mcuxClMath_ExactDivideOdd to calculate R' = X'/Y', and then calculates R = R' &gt;&gt; (trailingZeros(Y) % (8*MCUXCLPKC_WORDSIZE)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iR_iX_iY_iT</td><td>Pointer table indices of parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xPkcByteLength</td><td>length of X </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yPkcByteLength</td><td>length of Y</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>iR_iX_iY_iT</code>  </dt>
<dd><code>iT</code> (bits 0~7): index of temp (PKC operand). <br />
Its size shall be at least (3 * MCUXCLPKC_WORDSIZE). <br />
<code>iY</code> (bits 8~15): index of divisor Y (PKC operand), size = yPkcByteLength. <br />
The most significant PKC word of Y shall be nonzero. <br />
The offset (UPTRT[iY]) shall be exactly a multiple of MCUXCLPKC_WORDSIZE. <br />
<code>iX</code> (bits 16~23): index of dividend X (PKC operand), size = xPkcByteLength. <br />
X will be destroyed by this function. <br />
CAUTION: if the length of trimmed X' is MCUXCLPKC_WORDSIZE, this function will access to (read) one extra PKC word of X, i.e., X[xPkcByteLength ~ xPkcByteLength + MCUXCLPKC_WORDSIZE - 1]. The value of this PKC word will not affect correctness of the result, but caller shall ensure that this PKC word is accessible by PKC. If caller cannot guarantee the length of trimmed X' greater than MCUXCLPKC_WORDSIZE, X shall be stored in buffer of the size, xPkcByteLength + MCUXCLPKC_WORDSIZE. <br />
<code>iR</code> (bits 24~31): index of result R (PKC operand). Its buffer size shall be at least (xPkcByteLength - yPkcByteLength + 2*MCUXCLPKC_WORDSIZE). The result fits in size = (xPkcByteLength - yPkcByteLength + MCUXCLPKC_WORDSIZE). </dd>
<dt><code>xPkcByteLength</code>  </dt>
<dd>It shall be a multiple of MCUXCLPKC_WORDSIZE. </dd>
<dt><code>yPkcByteLength</code>  </dt>
<dd>It shall be a multiple of MCUXCLPKC_WORDSIZE. </dd>
</dl>
</dd>
</dl>
<dl>
<dt>PKC properties </dt>
<dd><dl>
<dt>PS1 lengths </dt>
<dd>Unused (modified and restored in the function). </dd>
<dt>PS2 lengths </dt>
<dd>PS2 OPLEN and MCLEN will be modified, and original values will not be restored. </dd>
<dt>ACTIV/GOANY </dt>
<dd>#mcuxClPkc_WaitForReady will be called before returning to caller. <br />
The PKC calculation might be still on-going, call #mcuxClPkc_WaitForFinish before CPU accesses to the result. </dd>
</dl>
</dd>
</dl>
<p>This function deinitializes PKC hardware, and optionally restores PKC configuration (except STOP bit).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pState</td><td>pointer to PKC state backup structure. If it's not a NULL pointer, PKC state will be restored from this structure.</td></tr>
  </table>
  </dd>
</dl>
<p>This function initializes elements in UPTR table. UPTR table contains the address (16-bit offset in PKC workarea) of each buffer (PKC operand). Each element of the table will be initialized with a 16-bit offset, associated with a buffer allocated in sequence in PKC workarea. When calling this function, there shall be no on-going and pending PKC calculations using the specified UPTR table elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pUPTRT</td><td>pointer to the first element to be initialized in UPTR table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBaseBuffer</td><td>address of the buffer in PKC workarea, with which the first element will be associated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferLength</td><td>byte length of each buffer in PKC workarea. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noOfBuffer</td><td>number of elements to be initialized.</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>pUPTRT</code>  </dt>
<dd>this pointer shall be 2-byte aligned. </dd>
<dt><code>pBaseBuffer</code>  </dt>
<dd>this address shall be MCUXCLPKC_WORDSIZE aligned. </dd>
<dt><code>bufferLength</code>  </dt>
<dd>this length shall be a multiple of MCUXCLPKC_WORDSIZE. </dd>
</dl>
</dd>
</dl>
<p>This function performs one specified PKC calculation, of which the operand(s) and result are specified by the indices of UPTR table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">param_mode</td><td>param (the higher 8 bits) indicates the type of the calculation (L0 or L1) and the parameter set (PS1 or PS2). <br />
 mode (the lower 8 bits) indicates the calculation, either an L0 operation or L1 microcode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iR_iX_iY_iZ</td><td>indices of the operand(s) and the result in UPTR table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>The PKC calculation might be still on-going when returning to caller, call #mcuxClPkc_WaitForFinish before CPU accesses to the result.</dd></dl>
<p>This function performs one specified PKC calculation, of which the operand(s) and result are specified by the indices of UPTR table, and a 8-bit constant parameter is directly provided. This function can also be used to perform an L0 operation without using Z operand, e.g., OP_MUL, R = X0 * Y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">param_mode</td><td>param (the higher 8 bits) indicates the type of the calculation (always L0) and the parameter set (PS1 or PS2). <br />
 mode (the lower 8 bits) indicates the calculation, an L0 operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iR_iX_iY_C</td><td>indices of the operand(s) and the result in UPTR table, and a direct 8-bit constant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>The PKC calculation might be still on-going when returning to caller, call #mcuxClPkc_WaitForFinish before CPU accesses to the result.</dd></dl>
<p>This function triggers PKC to start the calculation of a FUP program.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUPTR</td><td>2-byte aligned address of the FUP program. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uLength</td><td>length (number of calculation) of the FUP program.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>The PKC calculation might be still on-going when returning to caller, call #mcuxClPkc_WaitForFinish before CPU accesses to the result.</dd></dl>
<p>This function waits until PKC finishes on-going and pending calculations (if there is any). When returning to caller, PKC is in idle state, and result in PKC workarea is ready.</p>
<p>This function waits until PKC is ready to accept next calculation (i.e., no pending calculation). </p>

</div>
</div>
<a id="gaf40f87ea9a6016cd444733991730d35d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf40f87ea9a6016cd444733991730d35d">&#9670;&nbsp;</a></span>MCUX_CSSL_FP_PROTECTED_TYPE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MCUX_CSSL_FP_PROTECTED_TYPE </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts number of trailing zero bits of a PKC operand. </p>
<p>Deprecated type for mcuxClSession protected status codes.</p>
<p>Deprecated type for RSA protected status codes.</p>
<p>Deprecated type for error codes used by code-flow protected PKC component functions.</p>
<p>Deprecated type for error codes used by code-flow protected mcuxClMemory component functions.</p>
<p>Deprecated type for error codes used by code-flow protected Math component functions.</p>
<p>Deprecated type for Key component error codes, returned by functions with code-flow protection.</p>
<p>Deprecated type for ELS driver protected status codes.</p>
<p>Deprecated type for mcuxClEcc component return codes.</p>
<p>Securely calculates modular exponentiation.</p>
<p>This function counts the number of trailing zero bits of a PKC operand at offset UPTRT[iX] and of size PS1 OPLEN.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iX</td><td>index of PKC operand</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>iX</code>  </dt>
<dd>index of X (PKC operand), size = operandSize. <br />
The offset (UPTRT[iX]) shall be exactly a multiple of MCUXCLPKC_WORDSIZE. </dd>
</dl>
</dd>
</dl>
<dl>
<dt>PKC properties </dt>
<dd><dl>
<dt>PS1 lengths </dt>
<dd>PS1 OPLEN defines operandSize and shall be exactly a multiple of MCUXCLPKC_WORDSIZE. </dd>
<dt>PS2 lengths </dt>
<dd>Unused. </dd>
<dt>ACTIV/GOANY </dt>
<dd>This function will not use PKC, and assumes PKC will not modify the operand iX simultaneously. </dd>
</dl>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A code-flow protected error code (see <a class="el" href="group__mcux_cssl_flow_protection.html">Flow Protection API</a>) </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">#numTrailingZeroes</td><td>Number of trailing zeroes</td></tr>
  </table>
  </dd>
</dl>
<p>This function calculates modular exponentiation in a secure manner. It randomizes the computation by Euclidean splitting: exponent = b * q + r, where b is a 64-bit odd random number (with both MSbit and LSbit set), and r = exponent % b. The exponentiation is calculated by two steps: (1) m0 = m^q mod n; and (2) result = m0^b * m^r mod n. In addition, base operands are re-randomized, by adding random multiples of the modulus to them before performing modular multiplications.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSession</td><td>handle for the current CL session. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pExp</td><td>pointer to exponent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pExpTemp</td><td>pointer to temporary buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expByteLength</td><td>byte length of exponent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iT3_iX_iT2_iT1</td><td>indices of PKC operands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iN_iTE_iT0_iR</td><td>indices of PKC operands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secOption</td><td>option to disable the operand re-randomization</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>session:</code>  </dt>
<dd>The session pointed to by pSession has to be initialized prior to a call to this function. </dd>
<dt><code>pExp</code>  </dt>
<dd>the exponent is a big-endian octet string and shall be non-zero. </dd>
<dt><code>pExpTemp</code>  </dt>
<dd>the temporary buffer can be in either CPU or PKC workarea. <br />
It shall be CPU word aligned, and its length shall be a multiple of CPU word and greater than <code>expByteLength</code>. <br />
It can share the space with exponent (i.e., pExpTemp = pExp), but the exponent will be overwritten. </dd>
<dt><code>iT3_iX_iT2_iT1</code>  </dt>
<dd><code>iT1</code> (bits 0~7): index of temp1 (PKC operand). <br />
Its size shall be at least max(MCUXCLPKC_ROUNDUP_SIZE(<code>expByteLength</code> + 1), lenN + MCUXCLPKC_WORDSIZE, 2 * MCUXCLPKC_WORDSIZE). <br />
<code>iT2</code> (bits 8~15): index of temp2 (PKC operand). <br />
Its size shall be at least max(lenN + MCUXCLPKC_WORDSIZE, 2 * MCUXCLPKC_WORDSIZE). <br />
<code>iX</code> (bits 16~23): index of base number (PKC operand), size = operandSize + MCUXCLPKC_WORDSIZE (= lenN + MCUXCLPKC_WORDSIZE). <br />
It will be overwritten. <br />
<code>iT3</code> (bits 24~31): index of temp3 (PKC operand). <br />
Its size shall be at least max(lenN + MCUXCLPKC_WORDSIZE, 2 * MCUXCLPKC_WORDSIZE). </dd>
<dt><code>iN_iTE_iT0_iR</code>  </dt>
<dd><code>iR</code> (bits 0~7): index of result (PKC operand). <br />
The size shall be at least max(MCUXCLPKC_ROUNDUP_SIZE(<code>expByteLength</code> + 1), lenN + MCUXCLPKC_WORDSIZE). <br />
<code>iT0</code> (bits 8~15): index of temp0 (PKC operand). <br />
The size shall be at least max(MCUXCLPKC_ROUNDUP_SIZE(<code>expByteLength</code> + 1), lenN + MCUXCLPKC_WORDSIZE). <br />
<code>iTE</code> (bits 16~23): index of temp4 (PKC operand). <br />
The size shall be at least (6 * MCUXCLPKC_WORDSIZE). <br />
<code>iN</code> (bits 24~31): index of modulus (PKC operand), size = operandSize (= lenN). <br />
The upper 32 bits of N shall be null, which can be obtained for instance by applying 32-bit modulus blinding, or by artificially increasing PS1 lengths and all buffer sizes by 1 PKC word. <br />
NDash of modulus shall be stored in the PKC word before modulus. </dd>
</dl>
</dd>
</dl>
<dl>
<dt>PKC properties </dt>
<dd><dl>
<dt>PS1 lengths </dt>
<dd>PS1 OPLEN = MCLEN defines operandSize = <a class="el" href="group___m_c_u_x_c_l_p_k_c___m_i_s_c__.html#ga5d67b3705403f3a0cab0d71316df929b" title="Round-up a length to a multiple of PKC wordsize.">MCUXCLPKC_ROUNDUP_SIZE(lenN)</a>, where lenN is the length of modulus n. As the upper 32 bits of N should be null, operandSize &gt;= lenN + 4 bytes. </dd>
<dt>PS2 lengths </dt>
<dd>PS2 OPLEN and MCLEN will be modified, and original values will not be restored. </dd>
<dt>ACTIV/GOANY </dt>
<dd>#mcuxClPkc_WaitForReady will be called before returning to caller. The PKC calculation might be still on-going, call #mcuxClPkc_WaitForFinish before CPU accesses to the result. </dd>
</dl>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A code-flow protected error code (see <a class="el" href="group__mcux_cssl_flow_protection.html">Flow Protection API</a>) </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__mcux_cl_math___macros.html#gacc4f37c95272b523a0ca1eca8d2e3735" title="Math operation successful.">MCUXCLMATH_ERRORCODE_OK</a></td><td>function executed successfully </td></tr>
    <tr><td class="paramname"><a class="el" href="group__mcux_cl_math___macros.html#ga1427ab8cd82a164dee226ae554894772" title="Error occurred during Math operation.">MCUXCLMATH_ERRORCODE_ERROR</a></td><td>error occurred during operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>This function uses PRNG which has to be initialized prior to calling the function. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
